// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_XZQH_XZQH_H_
#define FLATBUFFERS_GENERATED_XZQH_XZQH_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 25 &&
              FLATBUFFERS_VERSION_MINOR == 12 &&
              FLATBUFFERS_VERSION_REVISION == 19,
             "Non-compatible flatbuffers version included");

namespace XZQH {

struct Coordinate;

struct Region;
struct RegionBuilder;

struct Data;
struct DataBuilder;

enum Level : int8_t {
  Level_Province = 0,
  Level_Prefecture = 1,
  Level_County = 2,
  Level_MIN = Level_Province,
  Level_MAX = Level_County
};

inline const Level (&EnumValuesLevel())[3] {
  static const Level values[] = {
    Level_Province,
    Level_Prefecture,
    Level_County
  };
  return values;
}

inline const char * const *EnumNamesLevel() {
  static const char * const names[4] = {
    "Province",
    "Prefecture",
    "County",
    nullptr
  };
  return names;
}

inline const char *EnumNameLevel(Level e) {
  if (::flatbuffers::IsOutRange(e, Level_Province, Level_County)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesLevel()[index];
}

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Coordinate FLATBUFFERS_FINAL_CLASS {
 private:
  float longitude_;
  float latitude_;

 public:
  Coordinate()
      : longitude_(0),
        latitude_(0) {
  }
  Coordinate(float _longitude, float _latitude)
      : longitude_(::flatbuffers::EndianScalar(_longitude)),
        latitude_(::flatbuffers::EndianScalar(_latitude)) {
  }
  float longitude() const {
    return ::flatbuffers::EndianScalar(longitude_);
  }
  float latitude() const {
    return ::flatbuffers::EndianScalar(latitude_);
  }
};
FLATBUFFERS_STRUCT_END(Coordinate, 8);

struct Region FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef RegionBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CODE = 4,
    VT_NAME = 6,
    VT_LEVEL = 8,
    VT_CENTER = 10,
    VT_CHILDREN = 12
  };
  const ::flatbuffers::String *code() const {
    return GetPointer<const ::flatbuffers::String *>(VT_CODE);
  }
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  XZQH::Level level() const {
    return static_cast<XZQH::Level>(GetField<int8_t>(VT_LEVEL, 0));
  }
  const XZQH::Coordinate *center() const {
    return GetStruct<const XZQH::Coordinate *>(VT_CENTER);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<XZQH::Region>> *children() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<XZQH::Region>> *>(VT_CHILDREN);
  }
  template <bool B = false>
  bool Verify(::flatbuffers::VerifierTemplate<B> &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_CODE) &&
           verifier.VerifyString(code()) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyField<int8_t>(verifier, VT_LEVEL, 1) &&
           VerifyField<XZQH::Coordinate>(verifier, VT_CENTER, 4) &&
           VerifyOffset(verifier, VT_CHILDREN) &&
           verifier.VerifyVector(children()) &&
           verifier.VerifyVectorOfTables(children()) &&
           verifier.EndTable();
  }
};

struct RegionBuilder {
  typedef Region Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_code(::flatbuffers::Offset<::flatbuffers::String> code) {
    fbb_.AddOffset(Region::VT_CODE, code);
  }
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(Region::VT_NAME, name);
  }
  void add_level(XZQH::Level level) {
    fbb_.AddElement<int8_t>(Region::VT_LEVEL, static_cast<int8_t>(level), 0);
  }
  void add_center(const XZQH::Coordinate *center) {
    fbb_.AddStruct(Region::VT_CENTER, center);
  }
  void add_children(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<XZQH::Region>>> children) {
    fbb_.AddOffset(Region::VT_CHILDREN, children);
  }
  explicit RegionBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Region> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Region>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Region> CreateRegion(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> code = 0,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    XZQH::Level level = XZQH::Level_Province,
    const XZQH::Coordinate *center = nullptr,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<XZQH::Region>>> children = 0) {
  RegionBuilder builder_(_fbb);
  builder_.add_children(children);
  builder_.add_center(center);
  builder_.add_name(name);
  builder_.add_code(code);
  builder_.add_level(level);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Region> CreateRegionDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *code = nullptr,
    const char *name = nullptr,
    XZQH::Level level = XZQH::Level_Province,
    const XZQH::Coordinate *center = nullptr,
    const std::vector<::flatbuffers::Offset<XZQH::Region>> *children = nullptr) {
  auto code__ = code ? _fbb.CreateString(code) : 0;
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto children__ = children ? _fbb.CreateVector<::flatbuffers::Offset<XZQH::Region>>(*children) : 0;
  return XZQH::CreateRegion(
      _fbb,
      code__,
      name__,
      level,
      center,
      children__);
}

struct Data FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef DataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ROOT = 4
  };
  const ::flatbuffers::Vector<::flatbuffers::Offset<XZQH::Region>> *root() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<XZQH::Region>> *>(VT_ROOT);
  }
  template <bool B = false>
  bool Verify(::flatbuffers::VerifierTemplate<B> &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ROOT) &&
           verifier.VerifyVector(root()) &&
           verifier.VerifyVectorOfTables(root()) &&
           verifier.EndTable();
  }
};

struct DataBuilder {
  typedef Data Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_root(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<XZQH::Region>>> root) {
    fbb_.AddOffset(Data::VT_ROOT, root);
  }
  explicit DataBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Data> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Data>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Data> CreateData(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<XZQH::Region>>> root = 0) {
  DataBuilder builder_(_fbb);
  builder_.add_root(root);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Data> CreateDataDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<::flatbuffers::Offset<XZQH::Region>> *root = nullptr) {
  auto root__ = root ? _fbb.CreateVector<::flatbuffers::Offset<XZQH::Region>>(*root) : 0;
  return XZQH::CreateData(
      _fbb,
      root__);
}

inline const XZQH::Data *GetData(const void *buf) {
  return ::flatbuffers::GetRoot<XZQH::Data>(buf);
}

inline const XZQH::Data *GetSizePrefixedData(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<XZQH::Data>(buf);
}

template <bool B = false>
inline bool VerifyDataBuffer(
    ::flatbuffers::VerifierTemplate<B> &verifier) {
  return verifier.template VerifyBuffer<XZQH::Data>(nullptr);
}

template <bool B = false>
inline bool VerifySizePrefixedDataBuffer(
    ::flatbuffers::VerifierTemplate<B> &verifier) {
  return verifier.template VerifySizePrefixedBuffer<XZQH::Data>(nullptr);
}

inline void FinishDataBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<XZQH::Data> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedDataBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<XZQH::Data> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace XZQH

#endif  // FLATBUFFERS_GENERATED_XZQH_XZQH_H_
